package smart_wallet

import (
	"context"
	"errors"
	"fmt"
	"log/slog"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/rpc"
	"github.com/shopspring/decimal"
)

var (
	res, ok                  = entryPointABI.Errors["SenderAddressResult"]
	senderAddressResultError = boolMust(res, ok)
)

func IsAccountDeployed(ctx context.Context, provider ethereum.ChainStateReader, swAddress common.Address) (bool, error) {
	byteCode, err := provider.CodeAt(ctx, swAddress, nil)
	if err != nil {
		return false, fmt.Errorf("failed to check if smart account is already deployed: %w", err)
	}

	// assume that the smart account is deployed if it has non-zero byte code
	return len(byteCode) != 0, nil
}

func GetAccountAddress(ctx context.Context, provider ethereum.ContractCaller, config Config, entryPointAddress, owner common.Address, index decimal.Decimal) (common.Address, error) {
	initCode, err := GetInitCode(config, owner, index)
	if err != nil {
		return common.Address{}, fmt.Errorf("failed to build initCode middleware: %w", err)
	}

	// calculate the smart wallet address that will be generated by the entry point
	// See https://github.com/eth-infinitism/account-abstraction/blob/v0.6.0/contracts/core/EntryPoint.sol#L356
	getSenderAddressData, err := entryPointABI.Pack("getSenderAddress", initCode)
	if err != nil {
		return common.Address{}, fmt.Errorf("failed to pack getSenderAddress data: %w", err)
	}

	msg := ethereum.CallMsg{
		To:   &entryPointAddress,
		Data: getSenderAddressData,
	}

	// this call must always revert (see EntryPoint contract), so we expect an error
	_, err = provider.CallContract(ctx, msg, nil)
	if err == nil {
		panic(fmt.Errorf("'getSenderAddress' call returned no error, but expected one"))
	}

	var scError rpc.DataError
	if ok := errors.As(err, &scError); !ok {
		return common.Address{}, fmt.Errorf("unexpected error type '%T' containing message %w)", err, err)
	}
	errorData := scError.ErrorData().(string)

	// check if the error signature is correct
	if id := senderAddressResultError.ID.String(); errorData[0:10] != id[0:10] {
		return common.Address{}, fmt.Errorf("'getSenderAddress' unexpected error signature: %s", errorData[0:10])
	}

	// check if the error data has the correct length
	if len(errorData) < 74 {
		return common.Address{}, fmt.Errorf("'getSenderAddress' revert data expected to have lenght of 74, but got: %d", len(errorData))
	}

	swAddress := common.HexToAddress(errorData[34:])
	if swAddress == (common.Address{}) {
		return common.Address{}, fmt.Errorf("'getSenderAddress' returned zero address")
	}

	return swAddress, nil
}

func GetInitCode(smartWalletConfig Config, ownerAddress common.Address, index decimal.Decimal) ([]byte, error) {
	var initCode []byte
	var err error

	switch typ := *smartWalletConfig.Type; typ {
	case SimpleAccountType:
		return nil, fmt.Errorf("%w: %s", ErrSmartWalletNotSupported, typ)
	case BiconomyType: // not tested
		initCode, err = GetBiconomyInitCode(ownerAddress, index, smartWalletConfig.Factory, smartWalletConfig.ECDSAValidator)
	case KernelType:
		initCode, err = GetKernelInitCode(ownerAddress, index, smartWalletConfig.Factory, smartWalletConfig.Logic, smartWalletConfig.ECDSAValidator)
	default:
		return nil, fmt.Errorf("unknown smart wallet type: %s", typ)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to get init code: %w", err)
	}

	return initCode, nil
}

// getKernelInitCode returns a middleware that sets the init code
// for a Zerodev Kernel smart account. The init code deploys
// a smart account if it is not already deployed.
func GetKernelInitCode(owner common.Address, index decimal.Decimal, factory, accountLogic, ecdsaValidator common.Address) ([]byte, error) {
	// Initialize Kernel Smart Account with default validation module and its calldata
	// see https://github.com/zerodevapp/kernel/blob/807b75a4da6fea6311a3573bc8b8964a34074d94/src/abstract/KernelStorage.sol#L35
	initData, err := kernelInitABI.Pack("initialize", ecdsaValidator, owner.Bytes())
	if err != nil {
		return nil, fmt.Errorf("failed to pack init data: %w", err)
	}

	// Deploy Kernel Smart Account by calling `factory.createAccount`
	// see https://github.com/zerodevapp/kernel/blob/807b75a4da6fea6311a3573bc8b8964a34074d94/src/factory/KernelFactory.sol#L25
	callData, err := kernelDeployWalletABI.Pack("createAccount", accountLogic, initData, index.BigInt())
	if err != nil {
		return nil, fmt.Errorf("failed to pack createAccount data: %w", err)
	}

	// Pack factory address and deployment data for `CreateSender` in EntryPoint
	// see https://github.com/eth-infinitism/account-abstraction/blob/v0.6.0/contracts/core/SenderCreator.sol#L15
	initCode := make([]byte, len(factory)+len(callData))
	copy(initCode, factory.Bytes())
	copy(initCode[len(factory):], callData)

	slog.Debug("built initCode", "initCode", hexutil.Encode(initCode))

	return initCode, nil
}

// getBiconomyInitCode returns a middleware that sets the init code for a Biconomy smart account.
// The init code deploys a smart account if it is not already deployed.
// NOTE: this was NOT tested. Use at your own risk or wait for the package to be updated.
func GetBiconomyInitCode(owner common.Address, index decimal.Decimal, factory, ecdsaValidator common.Address) ([]byte, error) {
	// Initialize SCW validation module with owner address
	// see https://github.com/bcnmy/scw-contracts/blob/v2-deployments/contracts/smart-account/modules/EcdsaOwnershipRegistryModule.sol#L43
	ecdsaOwnershipInitData, err := biconomyInitABI.Pack("initForSmartAccount", owner.Bytes())
	if err != nil {
		return nil, fmt.Errorf("failed to pack init data: %w", err)
	}

	// Deploy Biconomy SCW by calling `factory.createAccount`
	// see https://github.com/bcnmy/scw-contracts/blob/v2-deployments/contracts/smart-account/factory/SmartAccountFactory.sol#L112
	callData, err := biconomyDeployWalletABI.Pack("createAccount", ecdsaValidator, ecdsaOwnershipInitData, index.BigInt())
	if err != nil {
		return nil, fmt.Errorf("failed to pack createAccount data: %w", err)
	}

	// Pack factory address and deployment data for `CreateSender` in EntryPoint
	// see https://github.com/eth-infinitism/account-abstraction/blob/v0.6.0/contracts/core/SenderCreator.sol#L15
	initCode := make([]byte, len(factory)+len(callData))
	copy(initCode, factory.Bytes())
	copy(initCode[len(factory):], callData)

	slog.Debug("built initCode", "initCode", hexutil.Encode(initCode))

	return initCode, nil
}
